## 线程安全的生命周期管理
- 线程安全是这么定义的，本质上就是不存在数据竞争以及并发问题。
1.多个线程同时访问时，表现出正确的行为；无论操作系统如何调度这些线程，无论这些线程的执行顺序如何交织。
3.调用端代码无需额外的同步或者协调工作。
### 对象构造的线程安全
- 对象构造想要线程安全，唯一要求是在**构造期间不要泄露this指针**，这个主要考虑的因素是构造期间并没有完成初始化，那么别的线程可能会访问一个初始化一半的对象，会带来不可预知的后果。就你不要在构造函数中把this指针传给任何跨线程的对象。
- 正确做法是采用二段构造的方式，将this指针传递给其他对象这部放在一个init函数里。初始化后再调用init函数，这样虽然麻烦，但是安全。
### 对象析构的线程安全
- 相比于对象构造，对象析构就复杂很多了，因为构造一般只有一个线程去构造，而析构的话，因为你一个对象可能被多个线程持有，所以有可能会被多次析构。这个问题很严重。
- 首先，析构函数里不能加锁，析构函数会释放资源，其中一定包括锁，那么别的线程同样在等待锁的时候，如果锁被析构了，最轻进入临界区，coredump。
- 提前检查锁存不存在用处不大，因为没了锁的保护你这个操作不是原子的。
- 正确做法应该是直接用智能指针。
### 线程安全的观察者模式（Observer)
- observer就是说，我有一堆observer，然后一个observable，observer可以在observable上注册，同时observable可以通知observer事件。那么通知这个操作就有个问题了，我怎么知道这个资源还存在呢？
- 更一般的来说，面对对象有三个关系，继承、复合、委托。对于委托这个关系，我是可以和其他线程共享一个对象的，此时怎么保证我操作时不会析构呢？这跟浅拷贝也是一个问题。