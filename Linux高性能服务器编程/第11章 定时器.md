# 定时器
- 网络程序还需要处理定时事件，比如定期检查一个客户连接的活动状态。服务器程序一般有很多定时事件，不能一个定时事件一个信号，那样玩不过来。应该是一堆定时事件统一管理，然后一个周期触发的心跳信号，每次心跳检查有没有事件超时，然后处理事件。
- 管理定时事件需要某种容器的数据结构，如排序链表等，更高效一点的是时间轮与时间堆。
## 定时的方法
- 定时方法有三类，第一是socket选项中的SO_RCVTIMEO和SO_SNDTIMEO两个选项；第二是SIGALRM信号，第三是I/O复用的超时参数。一般来说，用于心跳触发的是SIGALRM信号，先用sigaction设置好SIGALRM信号，然后再用alarm()函数来触发它，alarm()函数的参数是触发SIGALRM信号的延时时间,alarm()函数调用1次只会触发一次。所以每次触发完SIGALRM都需要重新设置alarm()。
## 基于升序链表的定时器
- 定时事件通常要包括两个成员，一个是超时时间，一般由于直接调用系统时间time()来比较是否超时，所以都是绝对时间;与一个任务回调函数，一旦超时就触发这个回调函数并删除这个定时事件。有时候还需要一些被执行时需要传入的参数与是否重启定时器的信息等。
- 如果使用链表作为容器来存储定时事件，那么还需要前后指针，方便寻找下一个成员。
- 从执行效率来看，其插入删除事件的复杂度是O(n),触发任务的复杂度是O(1),具体链表定时器见项目中的源码。
## 高性能定时器
- 基于排序链表的定时器添加定时器的效率偏低，因此可以考虑一些更高性能的数据结构。如时间轮与时间堆等。
### 时间轮
- 时间轮就是一个环形数组等间隔排列，每个位置叫做槽，里面有一个链表，然后有一个指针每来一个定时信号就转一下，然后处理所指向槽里的定时事件。假设一个时间轮有N个槽，每个槽间隔si(slot interval)，那么运行一周就是N*s的时间。
- ![](/image/2022-01-10-16-00-46.png)
- 每个槽指向一个链表，一个链表上的定时事件具有相同的特征，他们的超时时间差N*si的整数倍。因此如果需要添加一个定时时间为ti的定时器，那么该定时器将被插入ts位置的链表中：

$$
ts=\left( cs+\left( ts/si \right) \right) \%N
$$

- 排序采用一个链表，而时间轮将所有定时事件平摊到每个槽上，每次处理还是处理一个链表，但是单个链表上的定时事件大大减少，提高了性能。
- 对于时间轮而言，如果想提高定时精度，那么就降低si，如果想提高执行效率就增加N，同时书上的做法是保存一个槽上定时事件的超时圈数，每触发一次就--，但是其实完全可以用一个统一的绝对圈数来衡量。这样插入删除事件就是O(n/N),而处理事件是O(1)。因为处理事件的次数肯定比插入删除的多，所以我觉得这样更合理一些。书上的做法插入删除是O(1),处理事件是O(n/N)。
- 具体见项目源码。
### 时间堆
- 前面的方案都是固定的心跳频率来实现定时检查的，但还有一个思路就是：将所有定时器中超时时间最小的到当前时间的间隔设成定时间隔。这样每次定时器到期，最小的一定被触发，然后再找到下一个最小的，把这个距离当前时间的时间间隔设成定时时间。
- 从一堆定时器超时时间里找到最小的这就是堆，用一个小根堆来实现。
- 其代价，插入删除O(logn),处理O(1)。