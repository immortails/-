# 高性能IO框架库Libevent
Linux服务器必须要处理的三类事件有IO事件，信号和定时事件。这三类事件主要考虑
1. 同一事件源。如果能统一三类事件既能让代码简单易懂，又能避免一些潜在的逻辑错误。一般的话利用IO复用和管道来管理所有事件。
2. 可移植性。不同操作系统具有不同的IO复用方式，所以要考虑服务器的可移植性。
3. 并发程序的支持，高性能IO框架库必然涉及并发操作。那么就得注意避免竞态条件。
## IO框架库描述
- IO框架库一般以库函数的形式，封装了底层的系统调用，给应用程序提供了一组更为便于使用的接口。这些库函数往往比程序员自己实现的更高效。
- 一般一个IO框架库要么是Reactor方式实现要么是Proactor方式实现。像Reactor方式实现的服务器有如下几个成分：句柄(Handle)，事件多路分发器（EventDemultiplexer),事件处理器(EventHandler),和具体的事件处理器(ConcreteEventHandler)。
![](/image/2022-01-11-15-01-54.png)
1. **句柄**：
    IO框架库要处理的对象，就是IO事件，信号与定时事件，统一称为事件源。**一般来说一个事件源应该和一个句柄绑定在一起**，当内核检测到就绪事件时，就通过句柄来通知应用程序。在Linux中，句柄就是文件描述符，信号事件对应的就是信号值。
2. **事件多路分发器**：
   事件的到来一般是异步的，随机的，我们无法预知事件什么时候到来，所以程序需要一直循环监听事件，当事件到来时，调用相应的事件处理器来处理它。等待事件通常用IO复用技术来实现。IO框架库将其封装成统一的接口，称为事件多路分发器。
   对于事件多路分发器，需要提供两个方法，一个是添加事件，一个是删除事件。
3. **事件处理器与具体事件处理器**：
   这个在平常写的小例子里面没有，就是一个for循环然后一堆if判断，但这是对于事件源比较少的情况可以这么干，对于大规模的事件源，我们不可能全部if判断处理，因此我们把每个if里面的东西抽象成一个事件处理器，将事件处理器与句柄绑定。
   同时一个句柄上可能会绑定着多个事件处理器；当句柄上有事件发生时，该句柄上所有事件处理器应该都被调用；所以引入事件队列来管理各个句柄上的事件处理器。每个句柄唯一的映射一个事件队列，这个事件队列管理所有和该句柄绑定的事件管理器。
   当有事件到来时，多路分发器根据事件源所绑定的句柄，分配给相应的事件队列，这个事件队列上所有的事件处理器都被调用。这样事件多路分发器可以很快将就绪的事件分发给相应的事件处理器。由于各种事件处理器都是不同的，所以这里把它定义为虚函数，派生出具体的每个事件处理器。
4. **Reactor**：
    Reactor就是IO事件框架库的核心，它提供几个方法是：
    handle_events:该方法用来执行事件循环
    register_handler:该方法调用多路事件分发器的register_event方法来往事件多路分发器中注册事件。
    remove_handler:调用事件多路分发器的remove_event方法来删除里面注册过的事件。
