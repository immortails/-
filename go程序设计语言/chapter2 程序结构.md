### 名称
- go中变量名称如果以大写字母开头，代表它是可以导出的，意味着它对外部是可见的。
### 声明
- 包级别声明的实体名字对这个包中所有文件可见（不管是不是一个文件）。
- 函数的声明由一个名字参数列表，可选的返回值列表构成。 函数名前面还可以再加一个声明用于将一个方法关联到一个类型上去。
```go
func (c Celsius) String() string {}
```
- 变量声明用var，后面可以加个等号用于初始化，go变量声明名字在类型前面;还可以短变量声明，用:=，这种就很像python的做法;一般来说局部变量的声明喜欢用短变量来声明，短变量声明可以声明一系列变量，同时其中也可以有前面已经声明的变量，此时短变量的作用就是赋值，但是一系列变量之间至少有一个用于声明的变量。
```go
var s string
s := "hello"
```
- go的指针和c中的指针差不多，除了不能++，--，指针里面存着一个地址。
- go里面注意，局部变量的地址是可以直接被函数返回的，因为变量的声明周期由垃圾回收器来进行管理，只有这个变量不可达时候，他才会被销毁。
```go
func f() *int {
    v := 1
    return &v
}
```
以上操作是ok的，因为v返回了一个地址，所以v依然可达。
- go中的new函数与cpp中的new函数的作用完全不同，go中的new只是根据给定的变量类型创建了一个**未命名**的变量，或者说是一个匿名变量，这点与cpp一致，但是new并不是在堆上去创建，它还是创建的是一个局部变量，**go中变量的生命周期全部由垃圾回收器来进行管理！**
- 局部变量会有一个动态的声明周期，每次执行声明语句时创建一个新的实体，变量一直生存到它变得无法访问，此时它占用的存储空间就会被回收。
- 局部变量也可以在堆中存在，比如返回一个地址，这样这个局部变量就可以被外部访问到，此时它的声明周期就被延长。这种情况可以被叫做逃逸。因为逃逸会在堆上分配内存，所以性能上会有损失。
- 类型声明就是type name underlying-type，就跟typedef差不多。
### 包和文件
- 一个包想要被引用，那么它就得放到gopath的src目录下，然后引用的时候直接写包名即可。
- 不用gopath的话就go mod，go mod直接就go mod tidy即可。
- 包想要执行一些初始化操作，可以写一系列init() 函数，init函数会按照声明的顺序自动执行。
```go
func init() {/* */}
```
- go的作用域注意一个if，多个if else if嵌套的时候，前一个if的初始化声明部分对后面的可见。以下做法是可行的。
```go
if x := f(); x == 0 {
    fmt.Println(x)
}else if y := g(x); x == y {
    fmt.Println(y)
}else {
    fmt.Println(x, y)
}
```
