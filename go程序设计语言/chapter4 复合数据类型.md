## 复合数据类型
复合数据类型就4种，数组，slice，map，结构体。
### 数组
- 数组是固定长度的，每个元素用索引访问，len()函数可以返回数组内元素个数，cap()可以返回数组容量。
- 默认情况下，一个数组中元素的初始值是0值，在数组字面量中，如果对数组长度的位置用...，那么就表示数组大小由初始元素个数决定。数组初始化的时候可以用**索引值**来初始化，这点与cpp不同。
```go
q := [...]int{1, 2, 3}
symbol := [...]string{USD: "$", EUR: "&", RMB:"￥"}
``` 
- Go传数组会拷贝一份，不同于cpp会退化成指针，它会拷贝数组元素，所以一般建议传指针，或者slice。slice比较好，因为它不定长。
## slice
- slice用于表示一个拥有相同类型元素的可变长度序列。每个slice都会对应一个底层数组，并且有三个属性：**指针长度与容量**。指针指向底层数组可访问的第一个节点，容量是slice第一个可访问的元素到底层数组最后一个可以访问的元素。slice可以由s[i:j]来创建一个新的slice，这个操作也可以在底层数组上做，这样会以该底层数组创建一个相应的slice，多个slice可以指向同一个底层数组。
- 因为多个slice可以指向同一个底层数组，一个slice修改后，底层数组就会改变，所以其他slice的元素也会改变。这里看起来不具备写时拷贝的操作。
- slice无法比较，因此不能用==来测试两个slice是否拥有相同的元素，主要原因是多个slice可能会公用一个底层数组，这样的话一个slice可能在不同时刻拥有不同的值，所以比较的意义不大。
- slice的零值是nil
- append函数操作的时候，直接复制到底层数组的末尾，注意这里不是slice的末尾，如果底层数组不够的时候，二倍扩容。用slice当队列的时候，实际上出队时候并没有free，所以这里会发生内存泄露，最好不要这么干。
- 如果两个slice指向同一个底层数组时候，那么哪个slice引起的扩容，slice就会指向新的底层数组，但另一个slice依然指向原来的底层数组。
- append不止可以追加一个元素。
```go
var x []int
x = append(x, 1)
x = append(x, 2, 3)
x = append(x, 4, 5, 6)
x = append(x, x...)
```
### map
- map就是go中的hash表/散列表， map[k]v这样来表示，go中的map还能排序，有点奇葩
- map初始化就用字面量ok,想初始化空的就直接不给里面放东西就行。
```go
ages := map[string]int{
    "alice": 31,
    "charlie": 34,
}
```
- map查找的时候，如果查找不到就会返回这种类型元素的零值，如果查找不到，ok就是false，第二个值是一个bool。
```go
age, ok := age["bob"]
```
### 结构体
- 结构体是将零个或者多个任意类型的命名变量组合在一起的聚合数据类型。
- 结构体访问的时候用点号，不管是值还是指针。
- 结构体的变量首字母一般都是大写的，这表明这个变量是可以导出的，一个结构体可以包含可导出与不可导出的变量，但是如果有不可导出的变量，那么就没办法用字面量来初始化，所以最好就是全部大写。
- 结构体有个很好用的功能，Go允许我们定义不带名称的结构体成员，类似于继承了，就是加个名字，就相当于拥有另一个结构体的所有变量,对于提高代码复用能力来说是很棒的一个功能。
```go
type Circle struct {
    Point
    Radius int
}
type Wheel struct {
    Circle
    Spokes int
}
```