## redis中数据结构与对象
- Redis中，每个键值对都是由对象组成的，对象一般有5种，分别是字符串对象，列表对象，哈希对象，集合对象，有序集合对象。
- 而数据结构的话有9种，对象由数据结构来实现，比如字符串对象的底层实现是SDS。
### 简单动态字符串
- redis没有直接使用字符数组，因为直接使用字符数组太原始了，redis再上面加了一层抽象，现在是简单动态数组SDS。
- 众所周知，redis是以K-V的形式存储的，key与value一般来说，key就是一个SDS，如：
```
SET msg "hello world"
```
- 这句话就是表示设置了一条记录，key是msg，value是"hello world"。不仅仅是作为key和value，SDS还可以作为缓冲区存在，比如在AOF缓冲区做持久化的时候，就是通过SDS来保存的。
- SDS是这么定义的：
```cpp
struct sdshdr{
    int len;        //记录buf数组中已使用的字节数量
    int free;       //记录buf中未使用字节数量
    char buf[];
}
```
- 虽然SDS是抽象出来的结构体，但是他还保留了部分C语言字符串的惯例，比如以'\0'结尾，这样带来的好处是，SDS可以直接使用C字符串中的大部分函数。
- SDS与c字符串区别有4点：
- - 首先是获取一个SDS len的长度复杂度为1，它通过len这个属性记录了SDS的长度。如何更新这部分由SDS自动来完成，而char[]的话，是需要strlen()函数一直遍历到非0才行。
- - 杜绝缓冲区溢出，这个是因为SDS可以动态的调整char数组，自动修改其大小。同时SDS的扩展不是你用多少我申请多少，pop掉我再释放的思路，这样频繁的申请和释放太浪费了，它采用预分配以及惰性释放的策略。就是有一个free的属性在，它表明了空闲的字符数量。对于小于1MB的，采用直接2倍扩容的思路，对于大于1MB的，直接2倍扩容有点浪费，所以每次只给1MB的扩容。
- - 二进制安全，这个主要是说，因为c中char[]数组很多都是以'\0'来进行结尾，所以说字符串中其实不能有'\0'这种字符，所以对于二进制保存，不是很安全，但SDS中不是以'\0'来判断结尾的，他有个属性len，这个属性可以判断是否读到结尾了。
- - 兼容C函数，虽然SDS是二进制安全，以len长度判断结尾，但是在buf中依然最后一位是'\0'，兼容了C字符串的特性。所以C中的函数部分也是可以直接用的。
### 链表
- 链表是的好处是高效的重排能力，以及其顺序的节点访问方式，用法比较灵活，但随机访问的性能较差。