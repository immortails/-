## lambda表达式
- lambda表达式可以理解为匿名函数，lambda表达式非常简单：
$$
[captures] (params) specifiers\,\,exception->ret(body)
$$
- - [captures] 意思是捕获列表，它可以捕获当前作用域0个或多个变量。
- - (params) 是可选参数列表，与普通的函数参数一样
- - specifiers 是指可选的限定符，比如mutable之类的。
- - expection 可选异常说明符
- - ret 可选的返回类型
- - body 函数体
- 捕获操作：捕获操作的变量需要是**作用域内且非静态的变量**，或者说可以自动存储的变量类型，如果捕获静态变量会报错，不过静态变量本身也不需要捕获，可以直接访问的。如果lambda表达式被定义到了全局的作用域上，那么此时捕获列表必须都为空。
捕获的参数传递形式与传参一致，捕获值的话会深拷贝一个新值，捕获引用的话，直接传引用。**捕获到的变量默认为常量**，也就是不能修改，引用的话因为内部存储的是一个地址，所以实际上你也没修改引用。不过你可以加个mutable来强行修改捕获的值。
捕获的话还有一些特殊的用法，[this]捕获this指针；[=]捕获当前作用域的所有值；[&]捕获当前作用域内所有引用。
### lambda表达式实现原理
- 本质上lambda表达式会在编译期间生成了一个闭包类，这个闭包类会生成一个对象，称为闭包。所谓闭包，就是一个**匿名的包含函数定义时上下文的一个函数对象**。
- 从本质上说，lambda表达式与手动生成的仿函数基本上原理一致，都是一个类重载了()运算符。不过仿函数是人手工实现的，更加灵活，lambda需要遵循lambda表达式的规则。
### c14-c20对lambda的升级
- 在c14中，lambda表达式提供了广义捕获的思路，原本的c11中的lambda捕获的参数只能是变量名，而在c14中，其可以是带等号的表达式，具体捕获的参数就是等号左边的参数。这对于异步调用类中的lambda表达式用处很大，如果调用的时候this指针已经被析构，那么此时就会输出一个未定义的行为，但如果捕获的时候[tmp=*this]直接将this的值赋值给tmp，就不会有this被析构的问题，因为此时this已经被深拷贝了。
- 在c14中，lambda表达式输入的参数还可以用auto推导，这在c11中是不允许的，auto推导一定程度上提供了泛型的能力，但是对于有关类的推导方式来说，auto不是很方便，在c20中提供了模板，就很强了。