## 同步原语
- 同步主要是为了解决**并行与并发**带来的一系列问题，并发是为了让多个执行流不停的切换来营造出同时运行的假象，提高用户的体验。
- 而并行是真实的使用多个多个执行流来同时运行程序，他能提高用户体验的同时，提升系统的性能。这两个操作都会带来同时访问共享内存带来的并发访问的问题。
- 并发访问主要会带来三个特性的丧失：**原子性**：一条指令的执行会被干扰；**顺序性**：编译器会优化代码调整顺序；**可见性**：CPU会对执行语句进行优化，语句不一定会按顺序执行。
- 保证原子性就要要求**互斥**，不允许两个以上的线程同时访问临界区；保证顺序性与可见性可以用memory barrier，memory barrier就是一个屏障，保证barrier后的代码一定不会优化到barrier前。
- 一般来说不要自己去尝试写并发程序，应该用前人已经写好的同步工具来实现并发。
### 互斥锁
- 互斥锁主要是用来解决原子性丧失的问题，原子性丧失的主要原因是多个线程同时访问临界区，发生了对共享资源的竞争，比如一个线程正在读，另一个线程就开始修改，导致两个线程的造成的结果不一致。解决的的方法就是保证临界区的互斥，可以给临界区上一把锁，然后谁拿到锁谁可以访问临界区。
- 纯软件实现的互斥非常难，这是因为拿到锁这一步需要先看锁的状态，然后再拿，这个操作不是原子的。有一个叫peterson算法的，只能实现2个线程的互斥；一般来说都是软硬结合的方式，就是通过硬件来保证一条原子操作来交换锁实现互斥，基本的实现的方式是这样的：
```cpp
int locked=0;
void lock(){
    while(xchg(&locked,1));
}

void unlock(){
    xchg(&locked,0);
}
```
- 互斥锁保证，若某个线程持有锁对象并且没有释放，那么其他线程无法获得锁。
- 互斥锁可以分为，**自旋锁与睡眠锁**，自旋锁是在用户态实现的，就是你会不停的去xchg尝试获得锁；而睡眠锁是锁放在内核空间，当你拿不到锁的时候，你就会阻塞，等待别人释放锁。因此自旋锁的好处就是快，如果有锁的话，你能立刻拿到锁，但是如果没有锁的话，你就会空转，浪费CPU资源；而睡眠锁的好处就是你不会去空转，会把CPU资源让给别的线程，但问题是你每次尝试获得锁都会进出内核，会有一定的开销。
- 一般来说，当锁用的比较多或者临界区长的时候，你就用睡眠锁；而当锁用的比较少或者临界区短的时候，直接自旋。
- 在使用锁的时候，一般需要**关中断**，因为如果中断的执行函数同样想获得这把锁，这时就会死锁。
- 锁比较好的实现是Linux的**futex**：它可以先在用户态里尝试获得锁，如果拿不到锁的话就进入睡眠；
```cpp
void futex_lock(){
    while(1){
        int r=xchg(&locked,1);
        if(r==0) break;
        syscall(SYS_futex,&locked,FUTEX_WAIT,1);
    }
}

void futex_unlock(){
    xchg(&locked,0);
    syscall(SYS_futex,&locked,FUTEX_WAKE,1);
}
```
- 它提供两个操作wake与wait，这样两个操作相比于一般的wait在于它会在wait前，检查锁的状态，因为你查看锁后再wait，这是两个操作不是原子的，如果在中间释放锁，那么此时就没有人能唤醒这个线程了。
- POSIX提供的互斥锁操作有5个：
```cpp
#include<pthread.h>
int pthread_mutex_init(sem_t* sem,0,int value);   //第二个写0就是说进程内部的信号量
int pthread_mutex_destroy(sem_t* sem);
int pthread_mutex_lock(sem_t* sem);
int pthread_mutex_trylock(sem_t* sem);
int pthread_mutex_unlock(sem_t* sem);
```

### 条件变量
- 考虑到对同步的需求多种多样，除了互斥锁外，还有其他的同步工具，比如条件变量，信号量等。
- 条件变量是一种万能的同步方法，因为它的含义十分清晰：如果不满足某个条件，那么就睡眠。
- 条件变量需要三个操作：wait(cv),睡眠等待cv事件发生；signal(cv),如果有线程等待cv，就唤醒；broadcast(cv)，唤醒所有线程。
- 条件变量在wait时，会原子的释放锁，当重新唤醒时又会原子的获得锁，所以不会死锁。
- 条件变量的实现是需要锁的配合的：
```cpp
mutex_lock(&mutex);
while(!cond){
    wait(&cv,&mutex);
}
mutex_unlock(&mutex);
```
### 信号量
- 信号量其实就是一种可以实现加减原子操作的计数器。它有两个操作:**P操作与V操作**；P操作就是让信号量--，如果为0就阻塞等待，直到可以减了；V操作就是信号量++，如果从0到1就唤醒其他线程。
- 因此可以通过多个信号量的等待来实现同步，对上一个信号量做P操作，然后对下一个信号量做V操作，就可以实现按顺序执行。不过信号量的初值可以设的大一些，它不一定设为1，也就是说它可以**辅助控制多个线程访问共享资源**。
- 如果信号量的初值为1，其实它就退化成条件变量了。
- 在POSIX中提供的信号量操作一共有5个：
```cpp
#include<semaphore.h>
int sem_init(sem_t* sem,0,int value);   //第二个写0就是说进程内部的信号量
int sem_destroy(sem_t* sem);
int sem_wait(sem_t* sem);
int sem_trywait(sem_t* sem);
int sem_post(sem_t* sem);
```
### 读写锁
- 读写锁是一种特殊的互斥锁，因为如果只是只读的话，线程相互之间是不会干扰的，锁只需要保证写的线程与读的线程和其他写的线程互斥即可。读写锁的核心目标主要是要增大读者的并行度，简化读者加锁放锁的流程。
- 读写锁的实现有两种一种是**偏向读的读写锁**，另一种是**偏向写的读写锁**。所谓偏向读还是偏向写是根据如果当前已经有线程在读，然后来了一个写，那么后面的读到低是直接读还是等待写之后再读。因为如果直接读的话，写有可能会因为读的线程很多而一直等待；如果先写的话，后序读势必要阻塞。所以说是偏向读还是偏向写。
- 如下是一个偏向读者的读写锁，只有第一个读者和写这上写锁，其他只用增加读者计数即可，最后一个读者释放写锁。
- 而偏向写者的读写锁比较复杂，读者上锁时，先用条件变量检查一下是否有写者准备上锁，然后才能上锁；而写者上锁时同样需要用条件变量检查有无写者准备上锁，然后标记上我准备上锁，并用条件变量等待读者个数降为0。
```cpp
void lock_reader(rwlock* locker){
    lock(&locker->reader_lock);                             //保证reader_cnt的原子性。
    locker->reader_cnt++;
    if(lock->reader_cnt==1) lock(&locker->writer_lock);     //第一个读者上锁，其他不上锁
    unlock(&locker->reader_lock);
}


void unlock_reader(rwlock* locker){
    lock(&locker->reader_lock);
    locker->reader_cnt--;
    if(locker->reader_cnt==0) unlock(&lock->writer_lock);   //如果是最后一个读者我就解锁
    unlock(&locker->reader_lock);
}

void lock_writer(rwlock* locker){
    lock(&locker->writer_lock);
}

void unlock_writer(rwlock* locker){
    unlock(&lock->writer_lock);
}
```
### 死锁
- 死锁发生的情况是，当有多个线程同时访问临界区并获取资源时，由于**上锁的顺序不一致**导致发生循环等待而卡死。
- 死锁主要分为两种，AA型死锁与ABBA型死锁。AA型死锁就是一个线程上过锁了后又尝试上同一把锁，这种问题好解决，用可重入锁的方式，给锁标记一个持有对象，如果尝试上锁的人是线程持有者，那么就不去上锁就行。
- ABBA型死锁比较难解决，因为它是，多个线程之间循环等待导致的死锁，涉及到多把锁。想要解决就要在编写程序时**严格保证上锁的顺序**，有一种做法就是引入一个栈，每次上锁时就往栈中加一个标志，然后上锁时检查栈中的标志，如果有锁在它顺序之后那么就不上锁。
- 锁还会带来优先级反转的问题，这个在进程里已经说过了。